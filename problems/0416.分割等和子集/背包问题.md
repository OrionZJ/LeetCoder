# 背包问题

引用代码随想录的思维导图

![416.分割等和子集1](背包问题.assets/20210117171307407.png)

# 01背包

- n件物品
- w为容量上限的背包
- weight[i]：第i件物品的重量
- value[i]：第i件物品的价值

每件物品只能放入1次，装入哪些物品能让背包内物品总价值最高？

暴力解法：回溯算法-时间复杂度$$O(2^n)$$

## 二维dp数组

动态规划五部曲：

1. 确定dp数组下标含义

    `dp[i][j]` - 从下标为[0]到[i]的物品里取，放入容量为j的背包，此时的最大价值总和

2. 确定递推公式

    - 不放物品i：`dp[i][j] = dp[i - 1][j]`（物品重量大于背包容量，物品i放不进包里，背包价值不变；
    - 放物品i：`dp[i][j] = dp[i - 1][j - weight[i]] + value[i]`（`dp[i - 1][j - weight[i]]`是容量为j - weight[i]时未放物品i的最大价值，`dp[i - 1][j - weight[i]] + value[i]`是此时放入物品i后背包的最大价值；
    - 综上：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`


3. 初始化dp数组


    1. 容量j为0时，背包价值总和一定为0；

    2. 当j < weight[0]时，`dp[0][j] = 0`(背包容量比第0号物品小，放不进背包）；

    3. 当j > weight[0]时，`dp[0][j] = value[0]`（背包可以放下第0号物品）；

        ```c++
        //参考代码如下，全部初始化为0则可省略第一个for循环
        for (int j = 0; j < weight[0]; j++)
            dp[0][j] = 0;
        for (int j = weight[0]; j <= bagweight; j++) 
        	dp[0][j] = value[0];
        ```


4. 确定遍历顺序



5. 举例推导dp数组