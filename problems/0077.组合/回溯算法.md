# 回溯算法

解决问题分类：

- 组合（不强调顺序）
- 分割
- 子集
- 排列（强调顺序）
- 棋盘
- 其它

## 什么是回溯法

回溯法，也称回溯搜索法，是一种搜索的方式。

回溯是递归的副产品，有递归就有回溯。

回溯的本质是**穷举**，可以通过一些**剪枝**的操作提高效率。

回溯法的问题可以抽象为**树形结构**。

回溯法解决的是在集合中递归查找子集，**集合的大小构成了树的宽度，递归的深度，构成的树的深度**。

递归就要有终止条件，所以是一棵高度有限的树（N叉树）。

## 回溯三部曲

1. 递归函数返回值及参数

    ```c++
    void backtracking(参数)
    ```

2. 回溯函数终止条件

    ```c++
    if (终止条件) {
        存放结果;
        return;
    }
    ```

3. 回溯搜索遍历过程

    ```c++
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
    ```

    **for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，叶子节点一般就是找的其中一个结果。

回溯算法模板框架如下：

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 剪枝优化

将没有意义的遍历剪枝优化

# 77.组合问题

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

## 回溯三部曲：

1. 递归函数返回值及参数

    定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合

    函数里一定有两个参数，n、k，然后还需要一个参数，为int型变量startIndex，用来记录本层递归的中，集合从哪里开始遍历。

    ```c++
    vector<vector<int>> result; // 存放符合条件结果的集合
    vector<int> path; // 用来存放符合条件单一结果
    void backtracking(int n, int k, int startIndex) 
    ```

2. 回溯函数终止条件

    ```c++
    if (path.size() == k) {
        result.push_back(path);
        return;
    }
    ```

3. 回溯搜索遍历过程

    for循环每次从startIndex开始遍历，然后用path保存取到的节点i

    ```c++
    for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
        path.push_back(i); // 处理节点 
        backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
        path.pop_back(); // 回溯，撤销处理的节点
    }
    ```

    backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。

    backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。

## 剪枝优化

**可以剪枝的地方在递归中每一层的for循环所选择的起始位置**

**如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了**。

接下来看一下优化过程如下：

1. 已经选择的元素个数：`path.size()`;
2. 还需要的元素个数为: ` path.size()`;
3. 在集合n中至多要从该起始位置 : `n - (k - path.size()) + 1`，开始遍历。+1，因为包括起始位置，要一个左闭的集合。

优化后的for循环：

```c++
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```

# 216.组合总和III

在[1,2,3,4,5,6,7,8,9]这个集合中找到和为n的k个数的组合，每种组合中不存在重复的数字。

- 所有数字都是正整数。
- 解集不能包含重复的组合

整体思路与组合一致

剪枝：**已选元素总和如果已经大于n（题中要求的和）了，往后遍历就没有意义了，剪枝**

# 17.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

## for循环起点

本题开始用多个集合求组合

在求组合的过程中：

- 一个集合来求组合，需要startIndex
- 多个集合取组合，各个集合之间相互不影响，不用startIndex
- **排列问题，另一套分析套路**

# 39.组合总和

找出 candidates 中所有可以使数字和为 target 的组合，candidates 中的数字可以无限制重复被选取。

- 所有数字（包括 target）都是正整数。
- 解集不能包含重复的组合。

本题和77.组合，216.组合总和III的区别是：本题没有数量要求，可以无限重复，但是有总和的限制。所以递归没有层数的限制，只要选取的元素总和超过target，就返回

## 剪枝优化

对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。

```c++
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

# 40.组合总和II

找出 candidates 中所有可以使数字和为 target 的组合，candidates 中的每个数字在每个组合中只能使用一次。

和 39.组合总和 如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，**但还不能有重复的组合**，而 39.组合总和 是无重复元素的数组candidates

## 去重

**要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**

**树层去重，需要对数组排序**

```c++
// 要对同一树层使用过的元素进行跳过
if (i > startIndex && candidates[i] == candidates[i - 1]) {
    continue;
}
```

或增加used数组记录使用情况：

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。

在candidates[i] == candidates[i - 1]相同的情况下：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

```c++
// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
// used[i - 1] == false，说明同一树层candidates[i - 1]使用过
// 要对同一树层使用过的元素进行跳过
if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {
    continue;
}
```

